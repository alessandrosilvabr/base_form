{
  "name": "BaseForm",
  "tagline": "A simple and small form objects Rails plugin for ActiveRecord based projects.",
  "body": "## Why?\r\nIn a development day-to-day basis, we commonly are confronted with situations where we\r\nneed to save data in more than one database table, running it's own validations, and\r\nthe validations of the all context together. In most cases a Form Object is a perfect\r\nsolution to deliver those records in a fun and maintenable code.\r\n\r\nActually, there's a lot of another gems to do that, like the great\r\n[reform](https://github.com/apotonick/reform) or\r\n[activeform-rails](https://github.com/GCorbel/activeform-rails), which are a more complete\r\nsolution for this problem. But, if you are looking for something lighter, maybe this\r\ngem could fit well for you.\r\n\r\n## Installation\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'base_form'\r\n```\r\n\r\nAnd then execute:\r\n```bash\r\n$ bundle\r\n```\r\n\r\nOr install it yourself as:\r\n```bash\r\n$ gem install base_form\r\n```\r\n\r\n## Usage\r\nLet's suppose you want to create a\r\nsignup form (you can check this example in the dummy app on this gem specs), with\r\nreceiving a user email, a user password, a user password confirmation, and a plan. In your\r\nsignup form, you need to create an account for this user, associate it to a entrance plan\r\nif it's not given, and make this user as an owner of this recently created account. Of course,\r\nin this case, a simple user model saving will not be sufficient to save all those data and\r\naccomplish with the requested business logic. So, you go to the Form Objects way,\r\ninstalls this gem, creates your Ruby class to handle all this logic:\r\n\r\n```ruby\r\nclass SignupForm < BaseForm::Form\r\n\r\nend\r\n```\r\n\r\nWith this empty class created, the easy way to start may be adding the attributes expected\r\nin this form, like:\r\n\r\n```ruby\r\nclass SignupForm < BaseForm::Form\r\n  attribute :email\r\n  attribute :password\r\n  attribute :password_confirmation\r\n  attribute :plan, Plan, default: proc { Plan.default }\r\nend\r\n```\r\n\r\nNote, if you don't specifies a Plan to this form, it will call a default value, which in\r\nthis case is calling a proc that will call a `default` method in `Plan` model and probably\r\nthis will return the default plan instance, fetched from the database or something like that.\r\n\r\nLet's put some form specific validation here. For example, we don't want the Plan being forced\r\nwith an empty string for example:\r\n\r\n```ruby\r\nclass SignupForm < BaseForm::Form\r\n  # ... attributes, validations ...\r\n\r\n  validates :plan, presence: true\r\nend\r\n```\r\n\r\nNow you may be asking: What about email and password? Shouldn't they be validated as well?\r\nWell, you could, in fact, add all validations in this form instead put it in your models,\r\nbut sometimes you don't have much control of that.\r\nThen, I'm showing here the case that `User` model has those validations. Don't be mad ok? :)\r\n\r\nThe form validations are the first validations tha are performed before it try to persist\r\nsomething here. If this validation fails, for an example, the persist method will not even\r\nbe called, and we're done with it. Otherwise, it wil try to persist your logic, which we'll\r\nimplement next.\r\n\r\nOk, now, you need to set the records that you will persist here.\r\nIn this case is the `:user` you want to save, and the `:account` you will want to associate\r\nto this user. So, you add it there (I recommend you let this in the top of the class to make\r\nit clear):\r\n\r\n```ruby\r\nclass SignupForm < BaseForm::Form\r\n  use_form_records :user, :account\r\n\r\n  # ... attributes, validations ...\r\nend\r\n```\r\n\r\nThis line will automatically generate `attr_readers` to each record there, and will add these\r\nsymbols in an array called `form_records` in your class. To understand it better, let's talk\r\nabout the `persist` implementation itself.\r\n\r\nBy the rule, the `persist` method is obligatory, and not implementing it, will cause your form\r\nraise a `NotImplementedError` when calling `save` to it.\r\n\r\nAll things written inside `persist` method, will automatically run in a ActiveRecord transaction,\r\nand if some record have its validation failed, this will perform a Rollback and deliver the form\r\nto you with those erros grouped through `errors` method, like any AR model you are already\r\nfamiliar with.\r\n\r\nLet me stop to talk and show you something we can call as implementation of this:\r\n\r\n```ruby\r\nclass SignupForm < BaseForm::Form\r\n  # form records, attributes, validations, whatever\r\n\r\n  private # because isolation is still a necessary evil ;)\r\n\r\n  def persist\r\n    @account ||= Account.create plan: plan\r\n    @user ||= account.users.create user_params\r\n  end\r\n\r\n  def user_params\r\n    {\r\n      email: email,\r\n      password: password,\r\n      password_confirmation: password_confirmation,\r\n      account_owner: true\r\n    }\r\n  end\r\nend\r\n```\r\n\r\nSo, here is the thing, see the variables names I've associated there, are the name os\r\nform_records I've defined before. It tries to create an account, setting a plan to it\r\nand then tries to create a user associated to this brand new account.\r\n\r\nIs this `form_records` that will call each object associated here to check its errors,\r\nand group it in `errors` object in your form itself in case of some validation brakes,\r\nbut if all is fine, the form instance is returned to you and you will be able to call\r\nmethods like `persisted?`, `account`, `user`, `valid?` and etc...\r\n\r\nAre you still there? :D\r\n\r\nLet's see this class complete?\r\n\r\n```ruby\r\nclass SignupForm < BaseForm\r\n  use_form_records :account, :user\r\n\r\n  attribute :email\r\n  attribute :password\r\n  attribute :password_confirmation\r\n  attribute :plan, Plan, default: proc { Plan.default }\r\n\r\n  validates :plan, presence: true\r\n\r\n  private\r\n\r\n  def persist\r\n    @account ||= Account.create plan: plan\r\n    @user ||= account.users.create user_params\r\n  end\r\n\r\n  def user_params\r\n    {\r\n      email: email,\r\n      password: password,\r\n      password_confirmation: password_confirmation,\r\n      account_owner: true\r\n    }\r\n  end\r\nend\r\n```\r\n\r\nHmmmm, seems to be good enough. I hope this helps someone in the same way it\r\nhelped me. Thanks!\r\n\r\n## Contributing\r\n- Fork it\r\n- Make your implementations\r\n- Send me a pull request\r\n\r\nThank you!\r\n\r\n## License\r\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}